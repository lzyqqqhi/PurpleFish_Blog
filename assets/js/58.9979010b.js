(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{378:function(v,_,a){"use strict";a.r(_);var t=a(27),r=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"垃圾回收-运行机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收-运行机制"}},[v._v("#")]),v._v(" 垃圾回收 & 运行机制")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("垃圾回收（Garbage Collection, GC）")]),v._v("：自动检测不再被引用的对象，并释放其内存空间。")]),v._v(" "),_("li",[v._v("JavaScript 是“具有自动垃圾回收机制”的语言，开发者无需手动释放绝大多数内存。")])]),v._v(" "),_("h2",{attrs:{id:"垃圾回收的基本原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收的基本原理"}},[v._v("#")]),v._v(" 垃圾回收的基本原理")]),v._v(" "),_("h3",{attrs:{id:"引用计数-js高级程序设计"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#引用计数-js高级程序设计"}},[v._v("#")]),v._v(" 引用计数 js高级程序设计")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("机制")]),v._v("：每个对象有一个引用计数，被引用时 +1，被解除引用时 -1。引用计数为 0 时可回收。")]),v._v(" "),_("li",[_("strong",[v._v("缺点")]),v._v("：无法处理“循环引用”问题。")])]),v._v(" "),_("h3",{attrs:{id:"标记-清除-mark-and-sweep"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#标记-清除-mark-and-sweep"}},[v._v("#")]),v._v(" 标记-清除 (Mark and Sweep)")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("主流机制，现代浏览器通用")])]),v._v(" "),_("li",[_("strong",[v._v("流程")]),v._v("：\n"),_("ul",[_("li",[v._v("GC Roots（全局对象、当前执行上下文的变量）出发，遍历所有可以到达的对象，做上“被标记”。")]),v._v(" "),_("li",[v._v("未被标记的对象视为不可达（即“垃圾”），统一清除释放。")])])]),v._v(" "),_("li",[_("strong",[v._v("优势")]),v._v("：能有效解决循环引用问题。")])]),v._v(" "),_("h3",{attrs:{id:"_3-标记-整理-分代回收-回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-标记-整理-分代回收-回收"}},[v._v("#")]),v._v(" 3. 标记-整理 & 分代回收 回收")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("V8 等引擎优化，通过新生代（对象存活时间短）、老生代（存活时间长）区分回收策略")])]),v._v(" "),_("li",[v._v("新生代：采用"),_("strong",[v._v("Scavenge 算法")]),v._v("（复制+标记清除，速度快，少量对象） Scavenge")]),v._v(" "),_("li",[v._v("老生代：采用"),_("strong",[v._v("标记-清除&标记-整理")]),v._v("（腾出连续空间，防止内存碎片）")])]),v._v(" "),_("h4",{attrs:{id:"新生代回收-scavenge-算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#新生代回收-scavenge-算法"}},[v._v("#")]),v._v(" 新生代回收 —— Scavenge 算法")]),v._v(" "),_("ul",[_("li",[v._v("使用 "),_("strong",[v._v("复制算法（Copying GC）")])]),v._v(" "),_("li",[v._v("将内存分为两个半区："),_("strong",[v._v("From Space")]),v._v(" & "),_("strong",[v._v("To Space")])]),v._v(" "),_("li",[v._v("步骤：\n"),_("ul",[_("li",[v._v("活动对象从 From 复制到 To")]),v._v(" "),_("li",[v._v("清空 From")]),v._v(" "),_("li",[v._v("交换两者角色")])])])]),v._v(" "),_("p",[v._v("优点：")]),v._v(" "),_("ul",[_("li",[v._v("快速")]),v._v(" "),_("li",[v._v("避免内存碎片")])]),v._v(" "),_("p",[v._v("缺点：")]),v._v(" "),_("ul",[_("li",[v._v("需要双倍内存")]),v._v(" "),_("li",[v._v("不适合大对象")])]),v._v(" "),_("h4",{attrs:{id:"老生代回收-mark-sweep-mark-compact"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#老生代回收-mark-sweep-mark-compact"}},[v._v("#")]),v._v(" 老生代回收 —— Mark-Sweep & Mark-Compact")]),v._v(" "),_("h5",{attrs:{id:"mark-sweep-标记-清除"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mark-sweep-标记-清除"}},[v._v("#")]),v._v(" Mark-Sweep（标记-清除）")]),v._v(" "),_("ul",[_("li",[v._v("标记所有存活对象")]),v._v(" "),_("li",[v._v("清除未标记对象")]),v._v(" "),_("li",[v._v("有内存碎片问题")])]),v._v(" "),_("h5",{attrs:{id:"mark-compact-标记-整理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mark-compact-标记-整理"}},[v._v("#")]),v._v(" Mark-Compact（标记-整理）")]),v._v(" "),_("ul",[_("li",[v._v("在 Sweep 后整理空间")]),v._v(" "),_("li",[v._v("将存活对象向一侧移动，消除碎片")])]),v._v(" "),_("h5",{attrs:{id:"垃圾回收技术"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收技术"}},[v._v("#")]),v._v(" 垃圾回收技术")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("并行回收")]),v._v("：通过多个辅助线程同时处理垃圾回收任务，加速执行速度，减少主线程停顿时间 。")]),v._v(" "),_("li",[_("strong",[v._v("增量标记")]),v._v("：将垃圾回收任务拆分成多个小片段，间歇性执行，避免长时间主线程停顿（2011 年 V8 从全停顿标记切换到增量标记） 。")]),v._v(" "),_("li",[_("strong",[v._v("并发回收")]),v._v("：允许辅助线程在后台完成垃圾回收操作，主线程可继续执行 JavaScript 代码，避免挂起 。")]),v._v(" "),_("li",[_("strong",[v._v("惰性清理（Lazy Sweeping）")]),v._v("：在增量标记后，延迟清理非活动对象内存，按需逐步清理，减少主线程停顿 。")])]),v._v(" "),_("h4",{attrs:{id:"具体触发时机-按代划分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#具体触发时机-按代划分"}},[v._v("#")]),v._v(" 具体触发时机（按代划分）：")]),v._v(" "),_("h5",{attrs:{id:"_1-新生代-young-generation"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-新生代-young-generation"}},[v._v("#")]),v._v(" 1. "),_("strong",[v._v("新生代（Young Generation）")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("触发条件")]),v._v("：当新生代空间（通常是 "),_("strong",[v._v("Semi-Space")]),v._v("，默认约 "),_("strong",[v._v("1~16MB")]),v._v("）快被填满时。")]),v._v(" "),_("li",[_("strong",[v._v("回收方式")]),v._v("：Scavenge（快速复制存活对象到老生代或清理掉）。")]),v._v(" "),_("li",[_("strong",[v._v("特点")]),v._v("：频繁触发、停顿时间短（通常 <1ms）。")])]),v._v(" "),_("h4",{attrs:{id:"_2-老生代-old-generation"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-老生代-old-generation"}},[v._v("#")]),v._v(" 2. "),_("strong",[v._v("老生代（Old Generation）")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("触发条件")]),v._v("：\n"),_("ul",[_("li",[v._v("老生代空间占用达到阈值（动态调整，默认约 "),_("strong",[v._v("几百MB")]),v._v("）。")]),v._v(" "),_("li",[v._v("新生代对象晋升到老生代，导致老生代空间不足。")]),v._v(" "),_("li",[v._v("系统内存压力（如浏览器整体内存紧张）。")])])]),v._v(" "),_("li",[_("strong",[v._v("回收方式")]),v._v("：Mark-Sweep + Mark-Compact（标记-清除 + 整理）。")]),v._v(" "),_("li",[_("strong",[v._v("特点")]),v._v("：触发频率低，但停顿时间可能较长（V8 通过增量/并发优化降低影响）。")])]),v._v(" "),_("h4",{attrs:{id:"_3-特殊情况"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-特殊情况"}},[v._v("#")]),v._v(" 3. "),_("strong",[v._v("特殊情况")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("显式触发")]),v._v("：开发者可通过 "),_("code",[v._v("global.gc()")]),v._v("（需启动 Node.js 时加 "),_("code",[v._v("--expose-gc")]),v._v("）手动触发 GC，但"),_("strong",[v._v("不推荐")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("空闲时 GC")]),v._v("：V8 会利用浏览器/Node.js 事件循环的空闲时间（Idle GC）主动回收，减少用户感知延迟。")])]),v._v(" "),_("h3",{attrs:{id:"新生代晋升老生代"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#新生代晋升老生代"}},[v._v("#")]),v._v(" 新生代晋升老生代")]),v._v(" "),_("ul",[_("li",[v._v("新生代对象经历一次 GC 后仍存活")]),v._v(" "),_("li",[v._v("To 空间使用率超过 25%")]),v._v(" "),_("li",[v._v("大对象直接进入老生代")])]),v._v(" "),_("h4",{attrs:{id:"如何优化内存与避免泄漏"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何优化内存与避免泄漏"}},[v._v("#")]),v._v(" 如何优化内存与避免泄漏")]),v._v(" "),_("ul",[_("li",[v._v("尽量减少全局变量")]),v._v(" "),_("li",[v._v("用完及时解绑事件、清空定时器")]),v._v(" "),_("li",[v._v("控制闭包持有范围")]),v._v(" "),_("li",[v._v("较大的数据及时置为 null，断开引用")])])])}),[],!1,null,null,null);_.default=r.exports}}]);